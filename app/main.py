from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text, Date
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session, relationship
from pydantic import BaseModel
from typing import List, Optional

# --- SQLAlchemy Setup ---
SQLALCHEMY_DATABASE_URL = "sqlite:///./artifacts/onboarding.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# --- SQLAlchemy Models ---
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)
    email = Column(String, unique=True, index=True)
    role = Column(String)
    tasks = relationship("OnboardingTask", back_populates="owner")

class OnboardingTask(Base):
    __tablename__ = 'onboarding_tasks'
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(Text)
    due_date = Column(Date)
    status = Column(String, default='Pending')
    user_id = Column(Integer, ForeignKey('users.id'))
    owner = relationship("User", back_populates="tasks")

# Create the database tables
Base.metadata.create_all(bind=engine)

# --- Pydantic Models ---
class UserBase(BaseModel):
    email: str
    name: str
    role: str

class UserCreate(UserBase):
    pass

class UserSchema(UserBase):
    id: int
    class Config:
        orm_mode = True

# --- FastAPI App ---
app = FastAPI()

# --- Dependency ---
def get_db():
    """
    Provides a database session for FastAPI dependency injection.
    
    This function is a generator that creates a new SQLAlchemy database session
    for each request and ensures it's properly closed after the request completes.
    It's designed to be used as a dependency in FastAPI route handlers to manage
    database connections efficiently.
    
    Args:
        None
    
    Yields:
        Session: A SQLAlchemy database session instance that can be used to
            query and modify the database. The session is automatically committed
            or rolled back based on the success of the request.
    
    Raises:
        None: This function doesn't raise exceptions directly, but database
            operations using the yielded session may raise SQLAlchemy exceptions.
    
    Notes:
        - Uses the SessionLocal factory configured with the SQLite database
        - Implements the context manager pattern with try/finally
        - Ensures database connections are closed even if exceptions occur
        - Thread-safe for SQLite with check_same_thread=False
        - Used with FastAPI's Depends() for automatic dependency injection
    
    Example:
        >>> @app.get("/items/")
        ... def read_items(db: Session = Depends(get_db)):
        ...     return db.query(Item).all()
    
    Dependencies:
        - SessionLocal: SQLAlchemy session factory
        - Session: SQLAlchemy session class
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- API Endpoints ---
@app.post("/users/", response_model=UserSchema)
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """
    Creates a new user in the database.
    
    This endpoint accepts user information and creates a new user record in the
    database after validating that the email address is not already registered.
    It's typically used during the onboarding process to register new employees
    or users in the system.
    
    Args:
        user (UserCreate): A Pydantic model containing the user data to create.
            Required fields:
            - email (str): Unique email address for the user
            - name (str): Full name of the user
            - role (str): User's role in the organization
        db (Session): Database session provided by FastAPI dependency injection.
            Automatically managed by the get_db dependency.
    
    Returns:
        UserSchema: A Pydantic model representing the created user with all fields:
            - id (int): Auto-generated unique identifier
            - email (str): The user's email address
            - name (str): The user's full name
            - role (str): The user's role
    
    Raises:
        HTTPException: 
            - 400 Bad Request: If a user with the provided email already exists.
              Returns {"detail": "Email already registered"}
    
    Notes:
        - Email addresses must be unique across all users
        - The user ID is auto-generated by the database
        - The created user is immediately committed to the database
        - Uses SQLAlchemy ORM for database operations
        - The response model ensures only specified fields are returned
    
    Example:
        >>> # POST /users/
        >>> # Request body:
        >>> {
        ...     "email": "john.doe@example.com",
        ...     "name": "John Doe",
        ...     "role": "Software Engineer"
        ... }
        >>> # Response (201 Created):
        >>> {
        ...     "id": 1,
        ...     "email": "john.doe@example.com",
        ...     "name": "John Doe",
        ...     "role": "Software Engineer"
        ... }
    
    Dependencies:
        - User: SQLAlchemy model for the users table
        - get_db: Dependency function providing database session
    """
    db_user = db.query(User).filter(User.email == user.email).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    db_user = User(**user.dict())
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@app.get("/users/", response_model=List[UserSchema])
def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Retrieves a paginated list of all users from the database.
    
    This endpoint returns a list of users with support for pagination through
    skip and limit parameters. It's useful for displaying user lists in admin
    interfaces or for bulk user management operations.
    
    Args:
        skip (int, optional): Number of records to skip from the beginning.
            Used for pagination. Defaults to 0 (start from first record).
            Must be >= 0.
        limit (int, optional): Maximum number of records to return.
            Used to control page size. Defaults to 100. Maximum is 100
            to prevent excessive data transfer.
        db (Session): Database session provided by FastAPI dependency injection.
            Automatically managed by the get_db dependency.
    
    Returns:
        List[UserSchema]: A list of user objects, each containing:
            - id (int): Unique user identifier
            - email (str): User's email address
            - name (str): User's full name
            - role (str): User's role in the organization
            
            Returns empty list if no users exist or if skip exceeds total count.
    
    Raises:
        None: This endpoint doesn't raise HTTP exceptions but may encounter
            database errors which are handled by FastAPI's error handlers.
    
    Notes:
        - Results are not sorted by default (database order)
        - Pagination is zero-based (skip=0 returns first record)
        - The limit parameter prevents loading too many records at once
        - Useful for implementing paginated user lists in frontend
        - Consider adding sorting parameters for production use
    
    Example:
        >>> # GET /users/?skip=0&limit=10
        >>> # Response (200 OK):
        >>> [
        ...     {
        ...         "id": 1,
        ...         "email": "john.doe@example.com",
        ...         "name": "John Doe",
        ...         "role": "Software Engineer"
        ...     },
        ...     {
        ...         "id": 2,
        ...         "email": "jane.smith@example.com",
        ...         "name": "Jane Smith",
        ...         "role": "Product Manager"
        ...     }
        ... ]
    
    Dependencies:
        - User: SQLAlchemy model for the users table
        - get_db: Dependency function providing database session
    """
    users = db.query(User).offset(skip).limit(limit).all()
    return users

@app.get("/users/{user_id}", response_model=UserSchema)
def read_user(user_id: int, db: Session = Depends(get_db)):
    """
    Retrieves a single user by their ID.
    
    This endpoint fetches detailed information about a specific user identified
    by their unique ID. It's commonly used for viewing user profiles, editing
    user information, or retrieving user details for other operations.
    
    Args:
        user_id (int): The unique identifier of the user to retrieve.
            Must be a positive integer corresponding to an existing user.
        db (Session): Database session provided by FastAPI dependency injection.
            Automatically managed by the get_db dependency.
    
    Returns:
        UserSchema: A Pydantic model representing the requested user with fields:
            - id (int): The user's unique identifier (same as requested)
            - email (str): The user's email address
            - name (str): The user's full name
            - role (str): The user's role in the organization
    
    Raises:
        HTTPException:
            - 404 Not Found: If no user exists with the provided ID.
              Returns {"detail": "User not found"}
            - 422 Unprocessable Entity: If user_id is not a valid integer
              (handled automatically by FastAPI)
    
    Notes:
        - The user_id is extracted from the URL path
        - Only returns the user if they exist in the database
        - Does not include related data (like tasks) in the response
        - Consider adding authentication/authorization in production
        - The response model ensures consistent field formatting
    
    Example:
        >>> # GET /users/1
        >>> # Response (200 OK):
        >>> {
        ...     "id": 1,
        ...     "email": "john.doe@example.com",
        ...     "name": "John Doe",
        ...     "role": "Software Engineer"
        ... }
        
        >>> # GET /users/999 (non-existent user)
        >>> # Response (404 Not Found):
        >>> {
        ...     "detail": "User not found"
        ... }
    
    Dependencies:
        - User: SQLAlchemy model for the users table
        - get_db: Dependency function providing database session
    """
    db_user = db.query(User).filter(User.id == user_id).first()
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user
